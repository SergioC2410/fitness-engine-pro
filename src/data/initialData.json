import { useState, useEffect, useCallback, useMemo
} from "react";

const STORAGE_KEY = "sergio_fitness_data";
const DAY_ORDER = {
  Lunes: 1,
  Martes: 2,
  MiÃ©rcoles: 3,
  Jueves: 4,
  Viernes: 5,
  SÃ¡bado: 6,
  Domingo: 7,
};

function mergeNutrition(oldNutri = [], newNutri = []) {
  const mergedMap = new Map();
  oldNutri.forEach((item) => mergedMap.set(item.day, item));
  newNutri.forEach((item) => {
    const existing = mergedMap.get(item.day) || {};
    mergedMap.set(item.day,
        { ...existing, ...item
        });
    });
  return Array.from(mergedMap.values()).sort(
    (a, b) => (DAY_ORDER[a.day
    ] || 99) - (DAY_ORDER[b.day
    ] || 99),
  );
}

function mergeMobility(oldMob = [], newMob = []) {
  const uniqueKeys = new Set();
  const result = [];
  const process = (list) => {
    list.forEach((item) => {
      const key = `${item.day
            }-${item.activity
            }-${item.distance
            }`;
      if (!uniqueKeys.has(key)) {
        uniqueKeys.add(key);
        result.push(item);
            }
        });
    };
  process(newMob);
  process(oldMob);
  return result.sort(
    (a, b) => (DAY_ORDER[a.day
    ] || 99) - (DAY_ORDER[b.day
    ] || 99),
  );
}

function mergeWeek(updatedData, incomingWeek) {
  const index = updatedData.findIndex(
    (w) => w.weekLabel === incomingWeek.weekLabel,
  );

  if (index === -1) {
    updatedData.push(incomingWeek);
    } else {
    const existingWeek = updatedData[index
        ];
    updatedData[index
        ] = {
      ...existingWeek,
      ...incomingWeek,
      nutritionData: mergeNutrition(
        existingWeek.nutritionData,
        incomingWeek.nutritionData,
      ),
      trainingData: {
        ...existingWeek.trainingData,
        ...incomingWeek.trainingData,
            },
      mobilityData: mergeMobility(
        existingWeek.mobilityData,
        incomingWeek.mobilityData,
      ),
        };
    }
}

export function useFitnessData() {
  const [appData, setAppData
    ] = useState(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      return saved ? JSON.parse(saved) : [];
        } catch (error) {
      console.error("Error init LocalStorage:", error);
      return [];
        }
    });

  // ðŸ”¥ CORRECCIÃ“N CRÃTICA: Inicializamos la app en la ÃšLTIMA semana registrada (la mÃ¡s reciente)
  const [activeWeek, setActiveWeek
    ] = useState(() => {
    return appData.length > 0 ? appData.length - 1 : 0;
    });

  useEffect(() => {
    if (appData.length > 0) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
        }
    },
    [appData
    ]);

  const currentWeek = useMemo(
    () => appData[activeWeek
    ] || null,
    [appData, activeWeek
    ],
  );

  const currentStreak = useMemo(() => {
    if (!appData || appData.length === 0) return 0;
    
    const allDays = [];
    appData.forEach(week => {
      for (let i = 0; i < 7; i++) {
        const dayName = ['Lunes', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado', 'Domingo'
                ][i
                ];
        
        const hasNutrition = week.nutritionData?.some(d => d.day === dayName);
        const trainingObj = week.trainingData?.[i.toString()
                ];
        const hasTraining = trainingObj?.hasData === true;
        const hasMobility = week.mobilityData?.some(d => d.day === dayName);

        const hasActivity = !!(hasNutrition || trainingObj || hasMobility);
        const isRest = !hasTraining && !hasMobility; 

        allDays.push({ dayName, hasActivity, isRest
                });
            }
        });

    let lastActiveIndex = allDays.length - 1;
    while (lastActiveIndex >= 0 && !allDays[lastActiveIndex
        ].hasActivity) {
      lastActiveIndex--;
        }

    if (lastActiveIndex < 0) return 0; 

    let streak = 0;
    let consecutiveRest = 0;

    for (let i = lastActiveIndex; i >= 0; i--) {
      const day = allDays[i
            ];

      if (!day.hasActivity) break; 

      if (day.isRest) {
        consecutiveRest++;
        if (consecutiveRest > 2) break;
            } else {
        consecutiveRest = 0;
            }

      streak++;
        }

    return streak;
    },
    [appData
    ]);

  const handleExport = useCallback((targetWeekLabel = null) => {
    if (appData.length === 0) return;
    
    let dataToExport = appData;
    let fileName = `fitness_backup_completo_${new Date().toISOString().split("T")[
                0
            ]
        }.json`;

    if (targetWeekLabel) {
      dataToExport = appData.filter(w => w.weekLabel === targetWeekLabel);
      const safeLabel = targetWeekLabel.replace(/[\/\s-
            ]/g, '_');
      fileName = `fitness_${safeLabel
            }.json`;
        }

    const dataStr = JSON.stringify(dataToExport,
        null,
        2);
    const blob = new Blob([dataStr
        ],
        { type: "application/json"
        });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
    },
    [appData
    ]);

  function processImportedFile(text, setAppData) {
    try {
      const imported = JSON.parse(text);
      const incomingWeeks = Array.isArray(imported)
        ? imported
        : [imported.data || imported
            ];

      if (incomingWeeks.length === 0) throw new Error("JSON vacÃ­o");

      setAppData((prevData) => {
        let updatedData = [...prevData
                ];

        incomingWeeks.forEach((incomingWeek) => {
          mergeWeek(updatedData, incomingWeek);
                });

        updatedData.sort((a, b) => a.weekLabel.localeCompare(b.weekLabel));
        
        // ðŸ”¥ ACTUALIZACIÃ“N DE INTERFAZ: Saltar a la semana mÃ¡s reciente tras importar
        setActiveWeek(updatedData.length - 1);
        
        return updatedData;
            });

      alert(
        `âœ… Datos fusionados correctamente.`,
      );
        } catch (err) {
      console.error("Import Error:", err);
      alert("âŒ Error: El archivo no es vÃ¡lido o estÃ¡ corrupto.");
        }
    }

  const handleImport = useCallback((e) => {
    const file = e.target.files?.[
            0
        ];
    if (!file) return;

    e.target.value = null;

    file.text().then((text) => {
      processImportedFile(text, setAppData);
        });
    },
    []);

  return {
    appData,
    activeWeek,
    setActiveWeek,
    currentWeek,
    handleImport,
    handleExport,
    currentStreak
    };
}